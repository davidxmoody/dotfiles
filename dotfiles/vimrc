" Open new files in insert mode
au BufNewFile * startinsert

" Miscellaneous 
set nocompatible
set ruler
set autoread
set ignorecase
set smartcase
set report=0
set scrolloff=4
set sidescrolloff=1
set listchars=extends:>,precedes:<
set directory=~/tmp,/var/tmp,/tmp,.
set clipboard=unnamedplus
set nojoinspaces
set number
syntax on

" '.' in visual mode repeats the last change on every line
vnoremap . :norm.<CR>

" Auto wrap comments
set textwidth=79
set formatoptions=crqn1j

" Some custom navigation bindings
noremap <Space> A
noremap <CR> o
noremap - o-<Space>

" Quick way to save and/or exit from insert mode
inoremap MM <ESC>ZZ
noremap MM ZZ
inoremap HH <ESC>:update<CR>
noremap HH :update<CR>
noremap M <Nop>
noremap S <Nop>
noremap H <Nop>

" Tabs and indenting
set tabstop=2
set softtabstop=2
set shiftwidth=2
set expandtab
set smarttab
set autoindent

" No wrapping
set nowrap

" Navigation with htns
noremap t j
noremap n k
noremap s l

noremap T 
noremap N 
noremap S L

noremap gt gj
noremap gn gk

noremap j n
noremap k J
noremap l t

noremap J N
noremap K gJ
noremap L T

" n is next and prev search results
" t is until
" s is substitute
" J is join
" K is lookup keyword

" Function for editing Python code
func! PythonMode()
  set tabstop=4
  set softtabstop=4
  set shiftwidth=4
endfu
au BufNewFile,BufRead *.py call PythonMode()

" Function for editing English text
func! WordProcessorMode()
  " Set syntax to markdown?
  syntax off
  set spell spelllang=en_gb
  set nonumber
  set wrap
  set linebreak
  set breakat=\ 
  set display=lastline
  set tabstop=4
  set softtabstop=4
  set shiftwidth=4
  set formatoptions=
  source ~/.vim/abbreviations.vim
endfu

com! WP call WordProcessorMode()
au BufNewFile,BufRead *.mkd call WordProcessorMode()
au BufNewFile,BufRead *.md call WordProcessorMode()
au BufNewFile,BufRead diary-*.txt call WordProcessorMode()

" Autocomplete script (http://vim.wikia.com/wiki/Autocapitalize_the_start_of_every_sentence)
"fun! CapWait(prev)
"	redraw
"	let next=nr2char(getchar())
"	if next=~'[.?!\r\n[:blank:]()]'
"		exe 'normal! i' . next . "\<Right>"
"		return CapWait(next)
"	elseif next=~'[\e]'
"		return "\<del>"
"	elseif a:prev=~'[\r\n[:blank:]]'
"		return toupper(next) . "\<del>"
"	else
"		return next . "\<del>"
"	endif
"endfun
"fun! CapHere()
"	let trunc = getline(".")[0:col(".")-2] 
"	return col(".")==1 ? CapWait("\r")
"	\ : trunc=~'[?!.]\s*$\|^\s*$' ? CapWait(trunc[-1:-1]) : "\<del>"
"endfun
"fun! InitTextFile()
"	im <buffer> <silent> . ._<Left><C-R>=CapWait('.')<CR>
"	im <buffer> <silent> ? ?_<Left><C-R>=CapWait('?')<CR>
"	im <buffer> <silent> ! !_<Left><C-R>=CapWait('!')<CR>
"	im <buffer> <silent> <CR> <CR>_<Left><C-R>=CapWait("\r")<R>
"	im <buffer> <silent> <NL> <NL>_<Left><C-R>=CapWait("\n")<CR>
"	nm <buffer> <silent> O O_<Left><C-R>=CapWait("\r")<CR>
"	nm <buffer> <silent> o o_<Left><C-R>=CapWait("\r")<CR>
"	nm <buffer> <silent> a a_<Left><C-R>=CapHere()<CR>
"	nm <buffer> <silent> A $a_<Left><C-R>=CapHere()<CR>
"	nm <buffer> <silent> i i_<Left><C-R>=CapHere()<CR>
"	nm <buffer> <silent> I I_<Left><C-R>=CapHere()<CR>
"	nm <buffer> <silent> s s_<Left><C-R>=CapHere()<CR>
"	nm <buffer> <silent> cc cc_<Left><C-R>=CapHere()<CR>
"	nm <buffer> <silent> cw cw_<Left><C-R>=CapHere()<CR>
"	nm <buffer> <silent> R R_<Left><C-R>=CapHere()<CR>
"	nm <buffer> <silent> C C_<Left><C-R>=CapHere()<CR>
"endfun
"au BufNewFile,BufRead *.txt call InitTextFile()
"au BufNewFile,BufRead *.md call InitTextFile()
"au BufNewFile,BufRead *.mkd call InitTextFile()
