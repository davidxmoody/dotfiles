" Function for editing English text
func! WordProcessorMode()
  " Set syntax to markdown?
  syntax off
  set spell
  set nonumber
  set wrap
  set linebreak
  set breakat=\ 
  set display=lastline
  source ~/.vim/abbreviations.vim
endfu

com! WP call WordProcessorMode()
au BufNewFile,BufRead *.mkd call WordProcessorMode()
au BufNewFile,BufRead *.md call WordProcessorMode()
au BufNewFile,BufRead diary-*.txt call WordProcessorMode()

" Open new files in insert mode
au BufNewFile * startinsert

" Miscellaneous 
set nocompatible
set ruler
set autoread
set ignorecase
set smartcase
set report=0
set scrolloff=4
set sidescrolloff=1
set listchars=extends:>,precedes:<
set directory=~/tmp,/var/tmp,/tmp,.
set clipboard=unnamedplus
set nojoinspaces
set number
syntax on

" Alternate binding for going from insert mode to normal mode and vice versa.
noremap <Space> A

" Bind enter to 'o' and '-' to add a new list item.
noremap <CR> o
noremap - o-<Space>

" Quick way to save and/or exit from insert mode.
inoremap MM <ESC>ZZ
noremap MM ZZ
inoremap HH <ESC>:update<CR>
noremap HH :update<CR>
noremap M <Nop>
noremap S <Nop>
noremap H <Nop>

" Tabs and indenting
set tabstop=2
set softtabstop=2
set shiftwidth=2
set expandtab
set smarttab
set autoindent

" No wrapping
set nowrap

" Navigation with htns.
noremap t j
noremap n k
noremap s l

noremap T 
noremap N 
noremap S L

noremap j n
noremap k J
noremap l t

noremap J N
noremap K gJ
noremap L T

" n is next and prev search results
" t is until
" s is substitute
" J is join
" K is lookup keyword

" Autocomplete script (http://vim.wikia.com/wiki/Autocapitalize_the_start_of_every_sentence)
"fun! CapWait(prev)
"	redraw
"	let next=nr2char(getchar())
"	if next=~'[.?!\r\n[:blank:]()]'
"		exe 'normal! i' . next . "\<Right>"
"		return CapWait(next)
"	elseif next=~'[\e]'
"		return "\<del>"
"	elseif a:prev=~'[\r\n[:blank:]]'
"		return toupper(next) . "\<del>"
"	else
"		return next . "\<del>"
"	endif
"endfun
"fun! CapHere()
"	let trunc = getline(".")[0:col(".")-2] 
"	return col(".")==1 ? CapWait("\r")
"	\ : trunc=~'[?!.]\s*$\|^\s*$' ? CapWait(trunc[-1:-1]) : "\<del>"
"endfun
"fun! InitTextFile()
"	im <buffer> <silent> . ._<Left><C-R>=CapWait('.')<CR>
"	im <buffer> <silent> ? ?_<Left><C-R>=CapWait('?')<CR>
"	im <buffer> <silent> ! !_<Left><C-R>=CapWait('!')<CR>
"	im <buffer> <silent> <CR> <CR>_<Left><C-R>=CapWait("\r")<R>
"	im <buffer> <silent> <NL> <NL>_<Left><C-R>=CapWait("\n")<CR>
"	nm <buffer> <silent> O O_<Left><C-R>=CapWait("\r")<CR>
"	nm <buffer> <silent> o o_<Left><C-R>=CapWait("\r")<CR>
"	nm <buffer> <silent> a a_<Left><C-R>=CapHere()<CR>
"	nm <buffer> <silent> A $a_<Left><C-R>=CapHere()<CR>
"	nm <buffer> <silent> i i_<Left><C-R>=CapHere()<CR>
"	nm <buffer> <silent> I I_<Left><C-R>=CapHere()<CR>
"	nm <buffer> <silent> s s_<Left><C-R>=CapHere()<CR>
"	nm <buffer> <silent> cc cc_<Left><C-R>=CapHere()<CR>
"	nm <buffer> <silent> cw cw_<Left><C-R>=CapHere()<CR>
"	nm <buffer> <silent> R R_<Left><C-R>=CapHere()<CR>
"	nm <buffer> <silent> C C_<Left><C-R>=CapHere()<CR>
"endfun
"au BufNewFile,BufRead *.txt call InitTextFile()
"au BufNewFile,BufRead *.md call InitTextFile()
"au BufNewFile,BufRead *.mkd call InitTextFile()
