bash_load_start=$(date "+%s%N")

# If not running interactively, don't do anything
case $- in
  *i*) ;;
    *) return;;
esac

# History settings
HISTCONTROL="erasedups:ignoreboth"
export HISTIGNORE="&:[ ]*:exit:ls:bg:fg:history:clear:u:x:f:b"
HISTTIMEFORMAT='%F %T '
shopt -s histappend
shopt -s cmdhist
HISTSIZE=5000
HISTFILESIZE=10000

# Misc options
shopt -s checkwinsize
shopt -s globstar
PROMPT_DIRTRIM=2
export LESS=RSci
export LC_COLLATE=C
export EDITOR=nvim

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi

# Custom prompt (with git support)
git_status() {
  local branch
  if branch=$(git rev-parse --abbrev-ref HEAD 2> /dev/null); then
    if [[ "$branch" == "HEAD" ]]; then
      echo '(DETACHED*) '
      return
    fi

    # Save space by abbreviating the most common branch name
    [[ "$branch" == "master" ]] && branch="m"

    local status=$(git status --porcelain 2> /dev/null)
    local status_indicator=''
    [[ "$status" != "" ]] && status_indicator='*'

    local commits_behind=$(git rev-list --count HEAD..@{upstream} 2>/dev/null)
    local commits_ahead=$(git rev-list --count @{upstream}..HEAD 2>/dev/null)
    local stashes_count=$(git stash list 2>/dev/null | wc -l)
    local commits_indicator=''
    [[ "$commits_ahead" -gt 0 ]] && commits_indicator="${commits_indicator}+${commits_ahead}"
    [[ "$commits_behind" -gt 0 ]] && commits_indicator="${commits_indicator}-${commits_behind}"
    [[ "$stashes_count" -gt 0 ]] && commits_indicator="${commits_indicator}#${stashes_count}"

    echo "(${branch}${commits_indicator}${status_indicator}) "
  fi
}

jobs_status() {
  local last_job_num=$(jobs | tail -n1 | cut -f1 -d'+') 
  if [[ ! -z "$last_job_num" ]]; then
    echo "$last_job_num "
  else
    echo ""
  fi
}

get_friendly_name() {
  sed "
    s%^/$%ROOT%;
    s%^$HOME$%HOME%;
    s%^$TMP_DIR\\(/\\)\\?.*$%TMP\1%;
    s%^$P_DIR$%P_DIR%;
    s%^$P_DIR/\\([^/]\\+\\)\\(/\\)\\?.*$%\\U\\1\\2%;
    s%^/\\([^/]\\+\\)\\(/[^/]\\+\\)\\(/\\)\\?.*$%/\\1\\2\\3%;
  " <<< "${1:-$PWD}"
}

update_tmux_window() {
  tmux rename-window "$(get_friendly_name)" >/dev/null 2>/dev/null
}

PS1='$(update_tmux_window)\[\033]0;\w\007\]\[\e[0;31m\]\w \[\e[0;33m\]$(git_status)\[\e[0;92m\]$(jobs_status)\[\e[0m\]'
PS2='\[\e[0;31m\]>\[\e[0m\] '

# Set some custom frequently used directories
export P_DIR="$HOME/p"
export RC_DIR="$P_DIR/dotfiles"
export TMP_DIR="$HOME/tmp"
export SYNC_DIR="$HOME/sync"
export DBOX="$HOME/.dbox/Dropbox"
export DIARY_DIR="$HOME/sync/diary-data"

# Path stuff
add_to_path() {
  if [ -d "$1" ] && [[ ":$PATH:" != *":$1:"* ]]; then
    PATH="$1${PATH:+":$PATH"}"
  fi
}

export N_PREFIX="$HOME/.n"
add_to_path "$N_PREFIX/bin"

add_to_path "$RC_DIR/bin"

export ANDROID_HOME=$P_DIR/android-sdk-linux
add_to_path "$ANDROID_HOME/platform-tools"
add_to_path "$ANDROID_HOME/tools"

# Alias definitions
[ -f ~/.bash_aliases ] && source ~/.bash_aliases
[ -f ~/.fzf.bash ] && source ~/.fzf.bash

# TODO this is temporary code for optimising my bash shell launch time, delete
# this and also the line at the top of the file
bash_load_end=$(date "+%s%N")
expr $bash_load_end - $bash_load_start >> ~/.bash-timing-logs

# Launch tmux if not already in tmux
[ -z "$TMUX" ] && echo "Launching tmux..." && tmux
